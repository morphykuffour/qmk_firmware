#include QMK_KEYBOARD_H
#if __has_include("keymap.h")
#    include "keymap.h"
#endif
#include <raw_hid.h>
#include "print.h"


/* THIS FILE WAS GENERATED!
 *
 * This file was generated by qmk json2c. You may or may not want to
 * edit it directly.
 */

#define KC_CTSC RCTL_T(KC_SCLN)
#define KC_CTLA LCTL_T(KC_A)
#define KC_LSHZ LSFT_T(KC_Z)
#define KC_RLSH RSFT_T(KC_SLSH)
#define KC_SPM2 LT(2, KC_SPC)
#define KC_BSM1 LT(1, KC_BSPC)
#define KC_GUTA GUI_T(KC_TAB)
#define KC_CLGV CTL_T(KC_GRV)

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
    [0] = LAYOUT_split_3x5_2(
        QK_BOOT, KC_W, KC_E, KC_R, KC_T, KC_Y, KC_U, KC_I, KC_O, KC_P, LSFT_T(KC_A), LT(5,KC_S), LT(1,KC_D), LT(3,KC_F), KC_G, KC_H, LT(4,KC_J), LT(2,KC_K), LT(6,KC_L), LSFT_T(KC_SCLN), KC_Z, LCTL_T(KC_X), LALT_T(KC_C), KC_V, KC_B, KC_N, KC_M, LALT_T(KC_COMM), LCTL_T(KC_DOT), KC_SLSH, KC_P0, KC_BSPC, LT(7,KC_SPC), KC_P1
    ),
    [1] = LAYOUT_split_3x5_2(
        KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_BTN1, KC_WH_U, KC_BTN2, KC_TRNS, KC_TRNS, KC_BTN2, KC_NO, KC_BTN1, KC_TRNS, KC_TRNS, KC_MS_L, KC_MS_D, KC_MS_U, KC_MS_R, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_WH_L, KC_WH_D, KC_WH_R, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS
    ),
    [2] = LAYOUT_split_3x5_2(
        KC_F1,   KC_F2,   KC_F3,   KC_F4,   KC_F5,           KC_F6,   KC_F7,   KC_F8,   KC_F9,   KC_F10,
        KC_TAB,  KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS,         KC_MINS, KC_EQL,  KC_LBRC, KC_RBRC, KC_PIPE,
        KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS,         KC_UNDS, KC_PLUS, KC_TRNS, KC_TRNS, QK_BOOT,
                                    KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS
    ),
    [3] = LAYOUT_split_3x5_2(
        KC_Q,    KC_W,    KC_E,    KC_R,    KC_T,            KC_Y,    KC_U,  KC_I,    KC_O,   KC_P,
        KC_CTLA, KC_S,    KC_D,    KC_F,    KC_G,            KC_H,    KC_J,  KC_K,    KC_L,   KC_SCLN,
        KC_LSHZ, KC_X,    KC_C,    KC_V,    KC_B,            KC_N,    KC_M,  KC_COMM, KC_DOT, KC_RLSH,
                                    KC_CLGV, KC_BSM1, KC_SPM2, KC_GUTA

    )
};

#ifdef OTHER_KEYMAP_C
#    include OTHER_KEYMAP_C
#endif // OTHER_KEYMAP_C

void keyboard_post_init_user(void) {
  // Customise these values to desired behaviour
  debug_enable=true;
  debug_matrix=true;
  debug_keyboard=true;
  //debug_mouse=true;
}

// The following code was printing debug statements but not switching layers
void raw_hid_receive(uint8_t *data, uint8_t length) {
    dprintf("\nReceived raw HID packet (length=%d):\n", length);
    // Print every byte received
    for (uint8_t i = 0; i < length; i++) {
        dprintf("data[%d] = 0x%02X\n", i, data[i]);
    }

    dprintf("Current layer state: 0x%08X\n", (unsigned int)layer_state);
    dprintf("Highest active layer: %d\n", get_highest_layer(layer_state));

    uint8_t command = data[0];  // Command is in first byte
    uint8_t layer = data[1];    // Layer is in second byte

    switch(command) {
        case 0x03: {  // Layer switch command
            dprintf("Command: Layer switch (0x00) to layer %d\n", layer);

            if (layer <= 3) {
                layer_clear();  // Clear all layers first
                layer_move(0);  // Force the layer to 0 (colemak-dh)
                
                uint8_t current = get_highest_layer(layer_state);
                dprintf("New layer: %d\n", current);

                // Must clear data buffer before setting response
                memset(data, 0, length);
                data[0] = 0x00;        // Success
                data[1] = current;      // Current layer
                data[2] = 0xAA;        // Acknowledgment
                
                dprintf("Layer switch successful\n");
            } else {
                dprintf("Invalid layer %d requested\n", layer);
                memset(data, 0, length);
                data[0] = 0xFF;  // Error
            }
            
            dprintf("Sending response\n");
            raw_hid_send(data, length);
            break;
        }

        default: {
            dprintf("Switching to qwerty\n");

            layer_clear();  // Clear all layers first
            layer_move(3);  // Force the layer to 3 (qwerty)
            
            uint8_t current = get_highest_layer(layer_state);
            dprintf("New layer: %d\n", current);

            memset(data, 0, length);
            data[0] = 0xFF;
            raw_hid_send(data, length);
            break;
        }
    }
}

// compile
// qmk compile -c -kb ferris/sweep -km default -e CONVERT_TO=rp2040_ce